function jointCords_ = skeleton_normalization4(jointCords, joint_selected, joint_ref, pair_selected, refCords)
% function to transform body joint coordinates by 1) subtracting
% the body reference joint position 2) transform the coordinates to
% body-centered joint coordinates system: from base to neck is the y axis+,
% from right hip to left hip is the x axis+, z is from base pointing
% forward, and 3) normalize the skeleton size to a reference skeleton 
% Input: jointCords: (number of joints*3)*T
%           joint_ref: idx of reference joint
% Output: x: (|joint_selected|*3)*T matrix

IDX = [3*joint_ref-2 3*joint_ref-1 3*joint_ref]; % z coordinate of reference joint
IDX_SHOULDER_NECK = [7 8 9];%[61 62 63];
IDX_HIP_LEFT = [37 38 39];
IDX_HIP_RIGHT = [49 50 51];
ref = jointCords(IDX,:);
ref(isnan(ref)) = 0; % clear corrupted data
njoint = size(jointCords,1)/3;

% normalizing w.r.t. to reference joint
% a copy of jointCords subtracting out reference joints
jointCords_ref = jointCords;
jointCords_ = jointCords;
for j = 1:njoint
    jointCords_ref(3*j-2:3*j,:) = jointCords_ref(3*j-2:3*j,:) - ref;
end

% normalize the joint distance w.r.t. reference skeleton
% sorted in the order of spanning from reference joint 21
% In general, the order of second node must be generated by forming a
% spanning tree whose root is the reference node
np = size(pair_selected,2);
for j = 1:np
    J1 = pair_selected(1,j);
    J2 = pair_selected(2,j);
    IDX1 = [3*J1-2 3*J1-1 3*J1];
    IDX2 = [3*J2-2 3*J2-1 3*J2];
    temp = jointCords(IDX2,:) - jointCords(IDX1,:);
    e = bsxfun(@rdivide,temp,sqrt(sum(temp.^2))); % 3*T matrix, each column is unit length
    e(isnan(e)) = 0; %%%%%%%%%% in case temp = 0
    s_ref = sqrt(sum((refCords(IDX2,:) - refCords(IDX1,:)).^2)); % scalar
    jointCords_ref(IDX2,:) = e*s_ref + jointCords_ref(IDX1,:); % need to update the jointCords_ref to use new joint position    
end
% IDX = sort([joint_selected*3-2 joint_selected*3-1 joint_selected*3]);
% jointCords_ref =  jointCords_ref(IDX,:);

count = 0;
for t = 1:size(jointCords,2)
    % r2
    n2 = norm(jointCords_ref(IDX_SHOULDER_NECK,t));
    if n2 == 0
        disp('skip frame where SHOULDER_NECK and REF distance is 0')
        continue;
    end
    r2 = jointCords_ref(IDX_SHOULDER_NECK,t)/n2; % should be normal vector
    % r1: first row of rotation matrix
    n1 = norm(jointCords_ref(IDX_HIP_LEFT,t) - jointCords_ref(IDX_HIP_RIGHT,t));
    if n1 == 0
        disp('skip frame where HIP_LEFT and HIP_RIGHT distance is 0')
        continue;
    end
    r1 = (jointCords_ref(IDX_HIP_LEFT,t) - jointCords_ref(IDX_HIP_RIGHT,t))/n1; % should be normal vector   
    % r3:
    r3 = cross(r1,r2);
    R = [r1';r2';r3'];
    temp = R*reshape(jointCords_ref(:,t),3,njoint);
    count = count + 1;
    jointCords_(:,count) = temp(:);
end

IDX = sort([joint_selected*3-2 joint_selected*3-1 joint_selected*3]);
jointCords_ = jointCords_(IDX,1:count);
