function x = skeleton_normalization2(jointCords, joint_selected, refCords)
% function to process body joint coordinates by first subtracting
% the body reference joint position and then normalize limbs distances
% w.r.t. corresponding reference skeleton 
% Input: jointCords: (number of joints*3)*T
%           joint_select: idx of selected joints
%           refCords: (number of joints*3)*1 !! (different from normalization 1)
% Output: x: (|joint_selected|*3)*T matrix

num_joints = size(jointCords,1)/3;
joint_ref = 1;%21
IDX = [3*joint_ref-2 3*joint_ref-1 3*joint_ref]; % z coordinate of reference joint
ref = jointCords(IDX,:);
ref(isnan(ref)) = 0; % clear corrupted data
ref(3,ref(3,:)==0) = 1;

% normalizing w.r.t. to reference joint
% a copy of jointCords subtracting out reference joints
jointCords_ref = jointCords;
for j = 1:size(jointCords,1)/3
    jointCords_ref(3*j-2:3*j,:) = jointCords_ref(3*j-2:3*j,:) - ref;
end
% normalize the joint distance w.r.t. reference skeleton
% sorted in the order of spanning from reference joint 21
% In general, the order of second node must be generated by forming a
% spanning tree whose root is the reference node
if num_joints == 20 % kinect v1
    %~ reference joint = 
    %~ reference joint = 1 case
    pair_selected = [1 2 1   13 14 15 1   17 18 19 3 3 5 6 7 3 9  10 11;
                             2 3 13 14 15 16 17 18 19 20 4 5 6 7 8 9 10 11 12];
elseif num_joints == 25 % kinect v2
    %~ reference joint = 21 case
    % pair_selected = [21 2  1   13 14 15 1   17 18 19 21 3 21 5 6  7 8   8   21 9   10 11 12 12;
    %                          2   1  13 14 15 16 17 18 19 20 3   4 5   6 7  8 22 23 9   10 11 12 24 25];
    %~ reference joint = 1 case
    pair_selected = [1 2   1   13 14 15 1   17 18 19 21 3 21 5 6  7 8   8   21 9   10 11 12 12;
                             2 21 13 14 15 16 17 18 19 20 3   4 5   6 7  8 22 23 9   10 11 12 24 25];
else
    error('Unsupported number of joints');
end
np = size(pair_selected,2);
for j = 1:np
    J1 = pair_selected(1,j);
    J2 = pair_selected(2,j);
    IDX1 = [3*J1-2 3*J1-1 3*J1];
    IDX2 = [3*J2-2 3*J2-1 3*J2];
    temp = jointCords(IDX2,:) - jointCords(IDX1,:);
    e = bsxfun(@rdivide,temp,sqrt(sum(temp.^2))); % 3*T matrix, each column is unit length
    s_ref = sqrt(sum((refCords(IDX2,:) - refCords(IDX1,:)).^2)); % scalar
    jointCords_ref(IDX2,:) = e*s_ref + jointCords_ref(IDX1,:); % need to update the jointCords_ref to use new joint position    
end
IDX = sort([joint_selected*3-2 joint_selected*3-1 joint_selected*3]);
x =  jointCords_ref(IDX,:);
