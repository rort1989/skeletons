function x = skeleton_normalization2(jointCords, joint_selected, joint_ref, pair_selected, refCords)
% function to process body joint coordinates by first subtracting
% the body reference joint position and then normalize limbs distances
% w.r.t. corresponding reference skeleton 
% Input: jointCords: (number of joints*3)*T
%           joint_select: idx of selected joints
%           joint_ref: idx of reference joint
%           pair_selected: 2*(number of pairs)
%           refCords: (number of joints*3)*1 !! (different from normalization 1)
% Output: x: (|joint_selected|*3)*T matrix

IDX = [3*joint_ref-2 3*joint_ref-1 3*joint_ref]; % z coordinate of reference joint
ref = jointCords(IDX,:);
ref(isnan(ref)) = 0; % clear corrupted data

% normalizing w.r.t. to reference joint
% a copy of jointCords subtracting out reference joints
jointCords_ref = jointCords;
for j = 1:size(jointCords,1)/3
    jointCords_ref(3*j-2:3*j,:) = jointCords_ref(3*j-2:3*j,:) - ref;
end
% normalize the joint distance w.r.t. reference skeleton
% sorted in the order of spanning from reference joint 21
% In general, the order of second node must be generated by forming a
% spanning tree whose root is the reference node
np = size(pair_selected,2);
for j = 1:np
    J1 = pair_selected(1,j);
    J2 = pair_selected(2,j);
    IDX1 = [3*J1-2 3*J1-1 3*J1];
    IDX2 = [3*J2-2 3*J2-1 3*J2];
    temp = jointCords(IDX2,:) - jointCords(IDX1,:);
    e = bsxfun(@rdivide,temp,sqrt(sum(temp.^2))); % 3*T matrix, each column is unit length
    s_ref = sqrt(sum((refCords(IDX2,:) - refCords(IDX1,:)).^2)); % scalar
    jointCords_ref(IDX2,:) = e*s_ref + jointCords_ref(IDX1,:); % need to update the jointCords_ref to use new joint position    
end
IDX = sort([joint_selected*3-2 joint_selected*3-1 joint_selected*3]);
x =  jointCords_ref(IDX,:);
